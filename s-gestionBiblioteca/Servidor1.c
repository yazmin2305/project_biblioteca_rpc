/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */
#include <string.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include "gestion_biblioteca.h"
#include "gestion_notificaciones.h"
datos_usuario vectorUsuario[4];
datos_libro vectorLibro[4];
datos_prestamo vectorPrestamo[4];
int posUsuario = 0;
int posLibro = 0;
int posPrestamo = 0;
int consultaVectorU(int *pId);
int consultaVectorL(int *pCodigo);
int consultaVectorPrestamo(int *pCodigo);
datos_prestamo * consultaPrestamo(datos_libro *argp);
int validacionMulta(int validarDia);

bool_t *
registrarusuario_1_svc(datos_usuario *argp, struct svc_req *rqstp)
{
	static bool_t  result;

	printf("Invocando registrar Personal\n");
	if(posUsuario<4){	
		// if(verificarPersonal(argp)){
			vectorUsuario[posUsuario]=*argp;
			result = TRUE;
			posUsuario++;
			printf("Registrando usuario\n");
		// }else{
		// 	printf("Usuario no registrado, ERROR en el formato de los datos ingresados\n");
		// 	result = FALSE;
		// }
	}
	else{
		printf("Cantidad máxima de registros alcanzados\n");
		result = FALSE;
	}
	return &result;
}

bool_t *
registrarlibro_1_svc(datos_libro *argp, struct svc_req *rqstp)
{
	static bool_t  result;
	printf("Invocando registrar Libro\n");
	if(posLibro<4){	
		vectorLibro[posLibro]=*argp;
		result = TRUE;
		posLibro++;
		printf("Registrando libro\n");
	}
	else{
		printf("Cantidad máxima de registros alcanzados\n");
		result = FALSE;
	}
	return &result;
}

int *
calcularmulta_1_svc(datos_libro *argp, struct svc_req *rqstp)
{
	static int  result;
	datos_prestamo *objP;
	objP = consultaPrestamo(argp);
	char* diaActual;
	char* mesActual;
	char fechaCopia2[20];
	char delimitadorFecha[] = "/";
	char* diaDevolucion;
	char* mesDevolucion;
	char fechaCopia[20];
	int validarDia = 0;
	int resultado = 0;

	//OBTENIENDO LA FECHA DEL SISTEMA
	// `time_t` es un tipo de tiempo aritm�tico
	time_t t;
	struct tm *tm;
	char fecha[100];
	
	t=time(NULL);
	// localtime convierte un valor de `time_t` a la hora del calendario y
	// devuelve un puntero a una estructura `tm` con sus miembros
	// rellenado con los valores correspondientes
	tm=localtime(&t);
	strftime(fecha, 100, "%d/%m/%Y", tm);
	//printf ("Hoy es: %s\n", fecha);

	//OBTENIENDO EL DIA ACTUAL
	strcpy((char*)fechaCopia2, fecha);
	char *tokenFecha2 = strtok(fechaCopia2, delimitadorFecha);
	if(tokenFecha2 != NULL){
		diaActual=tokenFecha2;
		tokenFecha2 = strtok(NULL, delimitadorFecha);
		if(tokenFecha2 != NULL){
			mesActual = tokenFecha2;
			tokenFecha2 = strtok(NULL, delimitadorFecha);
		}
	}
	//la funci�n strtol para convertir char* a int
	int diaActualConv = strtol(diaActual, NULL, 10);
	printf("Dia actual: %d\n", diaActualConv);
	
	//OBTENIENDO EL DIA EN QUE SE REALIZO EL PRESTAMO
	strcpy((char*)fechaCopia, (*objP).fechaDevolucion);
	char *tokenFecha = strtok(fechaCopia, delimitadorFecha);
	if(tokenFecha != NULL){
		diaDevolucion=tokenFecha;
		tokenFecha = strtok(NULL, delimitadorFecha);
		if(tokenFecha != NULL){
			mesDevolucion = tokenFecha;
			tokenFecha = strtok(NULL, delimitadorFecha);
		}
	}
	//la funci�n strtol para convertir char* a int
	int diaDevolucionConv = strtol(diaDevolucion, NULL, 10);
	printf("Dia devolucion: %d\n", diaDevolucionConv);

	//Validando si el mes actual es igual al mes del prestamo
	if(strcmp(mesDevolucion, mesActual) == 0){
		validarDia = diaActualConv - diaDevolucionConv;
		resultado = validacionMulta(validarDia);
		result = resultado;
		(*objP).valor_multa = resultado;
	}else{
		if(strcmp(mesDevolucion, "01") == 0 || strcmp(mesDevolucion, "03")==0 || strcmp(mesDevolucion, "05")==0 || strcmp(mesDevolucion, "07")==0 || strcmp(mesDevolucion, "08") == 0 || strcmp(mesDevolucion, "10")==0 || strcmp(mesDevolucion, "12")==0){
			int dia = 31 - diaDevolucionConv;
			printf("Dia: %d\n", dia);
			validarDia = diaActualConv + dia;
			printf("Dias multa: %d\n", validarDia);
			resultado = validacionMulta(validarDia);
			result = resultado;
			(*objP).valor_multa = resultado;
		}else if(strcmp(mesDevolucion, "04") == 0 || strcmp(mesDevolucion, "06")==0 || strcmp(mesDevolucion, "09")==0 || strcmp(mesDevolucion, "11")==0){
			int dia = 30 - diaDevolucionConv;
			printf("Dia: %d\n", dia);
			validarDia = diaActualConv + dia;
			printf("Dias multa: %d\n", validarDia);
			resultado = validacionMulta(validarDia);
			result = resultado;
			(*objP).valor_multa = resultado;
		}else if(strcmp(mesDevolucion, "02") == 0){
			int dia = 28 - diaDevolucionConv;
			printf("Dia: %d\n", dia);
			validarDia = diaActualConv + dia;
			printf("Dias multa: %d\n", validarDia);
			resultado = validacionMulta(validarDia);
			result = resultado;
			(*objP).valor_multa = resultado;
		}
	}

	return &result;
}

int *
abrirsesion_1_svc(datos_credencial *argp, struct svc_req *rqstp)
{
	static int  result;
	char* host = "localhost";
	CLIENT *clnt;
	bool_t  *result_1;
	char * enviarnotificacion_1_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, gestion_notificaciones_devolucion, gestion_notificaciones_devolucion_version, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

	result_1 = enviarnotificacion_1(&enviarnotificacion_1_arg, clnt);
	if (result_1 == (bool_t *) NULL) {
		clnt_perror (clnt, "call failed");
	}

	if((strcmp(argp->usuario, "admin")==0) && (strcmp(argp->clave, "1234")==0)){
		enviarnotificacion_1_arg = "Credenciales correctas\n";
		result_1 = enviarnotificacion_1(&enviarnotificacion_1_arg, clnt);

		result = 1;
	}else{
		enviarnotificacion_1_arg = "Credenciales no validas\n";
		result_1 = enviarnotificacion_1(&enviarnotificacion_1_arg, clnt);

		result = -1;
	}
	datos_usuario objUsu;
	//Validación del usuario
	for(int i=0; i<4; i++){
		if((strcmp(vectorUsuario[i].datosCredencial.usuario, argp->usuario)==0) && (strcmp(vectorUsuario[i].datosCredencial.clave, argp->clave)==0)){
			// printf("personal encontrado");
			enviarnotificacion_1_arg = "El personal esta autorizado para ingresar al sistema";
			result = 2;
			objUsu = vectorUsuario[i];
			result_1 = enviarnotificacion_1(&enviarnotificacion_1_arg, clnt);
			if(result_1 == (bool_t *) NULL){
				clnt_perror (clnt, "call failed\n");
			}
			break;
		}
	}

	//OBTENIENDO LA FECHA DEL SISTEMA
	// `time_t` es un tipo de tiempo aritm�tico
	time_t t;
	struct tm *tm;
	char fecha[100];
	
	t=time(NULL);
	// localtime convierte un valor de `time_t` a la hora del calendario y
	// devuelve un puntero a una estructura `tm` con sus miembros
	// rellenado con los valores correspondientes
	tm=localtime(&t);
	strftime(fecha, 100, "%d/%m/%Y", tm);
	
	for(int i=0; i<4; i++){
		if(vectorPrestamo[i].usuarioAsociado.id == objUsu.id){
			if(strcmp(vectorPrestamo[i].fechaDevolucion,fecha)==0){
				enviarnotificacion_1_arg = "Hoy es el día de la devolución del libro\n";
				result_1 = enviarnotificacion_1(&enviarnotificacion_1_arg, clnt);
			}
		}
	}

#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */

	return &result;
}

datos_usuario *
consultarusuario_1_svc(int *argp, struct svc_req *rqstp)
{
	static datos_usuario  result;

	printf("Invocando a consultar usuario\n");
	int res = consultaVectorU(argp);
	printf("\n---Identificador a buscar \n");
	if(res != -1){
		result = vectorUsuario[res];
		printf("Personal encontrado \n");
	}else{
		printf("NO se encontró el personal \n");
	}
	return &result;
}

datos_libro *
buscarlibro_1_svc(int *argp, struct svc_req *rqstp)
{
	static datos_libro  result;
	printf("Invocando a consultar Libro\n");
	int resL = consultaVectorL(argp);
	printf("\n Código a buscar \n");
	if (resL != -1)
	{
		result = vectorLibro[resL]; 
		printf("Libro encontrado \n");
	}
	else
	{
		printf("NO se encontró el libro \n");
	}
	return &result;
}

datos_prestamo *
consultarprestamo_1_svc(int *argp, struct svc_req *rqstp)
{
	static datos_prestamo  result;

	printf("Invocando a consultar prestamo\n");
	int resP = consultaVectorPrestamo(argp);
	printf("\n---Identificador a buscar \n");
	if(resP != -1){
		result = vectorPrestamo[resP];
		printf("Prestamo encontrado \n");
	}else{
		printf("NO se encontró el prestamo \n");
	}

	return &result;
}

bool_t *
realizarprestamo_1_svc(datos_prestamo *argp, struct svc_req *rqstp)
{
	static bool_t  result;

	printf("Invocando registrar Prestamo\n");
	if(posUsuario<4){	
		vectorPrestamo[posPrestamo]=*argp;
		result = TRUE;
		posPrestamo++;
		printf("Registrando Prestamo\n");
	}
	else{
		printf("Cantidad máxima de registros de prestamos alcanzados\n");
		result = FALSE;
	}

	return &result;
}

datos_libro *
prestamosusuario_1_svc(int *argp, struct svc_req *rqstp)
{
	static datos_libro  result;

	int i;
	for (i=0 ;  i<4; i++){
		if (vectorPrestamo[i].usuarioAsociado.id == *argp){
			result = vectorPrestamo[i].libroaPrestar;
			printf("codigo libroooo %d",result.codigo);
			break;
		}	
	}

	return &result;
}

int consultaVectorU(int *pId){
	int resultadoU=-1;
	int i ;
	for (i=0 ;  i<4 ; i++){
		if (vectorUsuario[i].id == *pId){
			resultadoU=i;
			break;
		}	
	}
	return resultadoU;
}
int consultaVectorL(int *pCodigo){
	int resultadoL=-1;
	int i ;
	for (i=0 ;  i<4; i++){
		if (vectorLibro[i].codigo == *pCodigo){
			resultadoL=i;
			break;
		}	
	}
	return resultadoL;
}
int consultaVectorPrestamo(int *pCodigo){
	int resultadoP=-1;
	int i ;
	for (i=0 ;  i<4; i++){
		if (vectorPrestamo[i].codigo == *pCodigo){
			resultadoP=i;
			break;
		}	
	}
	return resultadoP;
}
datos_prestamo * consultaPrestamo(datos_libro *argp){
	static datos_prestamo objP;
	int i;
	for (i=0 ;  i<4; i++){
		if (vectorPrestamo[i].libroaPrestar.codigo == (*argp).codigo){
			objP = vectorPrestamo[i];
			break;
		}	
	}
	return &objP;
}

int validacionMulta(int validarDia){
	int multa=0;
	if((validarDia>=1) && (validarDia<=3)){
		printf("multa 1 a 3 dias");
		multa = 10000;
		printf("El usuario debe pagar: %d\n",multa);
		
	}else if((validarDia>=4) && (validarDia<=8)){
		int dias = validarDia - 3;
		multa = 10000+(1000*dias);
		printf("El usuario debe pagar: %d\n",multa);
	}else if(validarDia>8){
		int dias = validarDia - 3;
		multa = 10000+(2000*dias);
		printf("El usuario debe pagar: %d\n",multa);
	}else{
		printf("El usuario no tiene multas\n");
	}
	return multa;
}
